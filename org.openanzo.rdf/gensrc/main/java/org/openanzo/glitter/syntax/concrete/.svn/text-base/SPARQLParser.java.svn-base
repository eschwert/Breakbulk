/* Generated By:JavaCC: Do not edit this line. SPARQLParser.java */
/******************************************************************************* 
 * Copyright (c) 2004, 2007-2009 IBM Corporation and Cambridge Semantics Incorporated. 
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution, and is available at 
 * http://www.eclipse.org/legal/epl-v10.html 
 * 
 * File: $Source: /cvsroot/slrp/glitter/com.ibm.adtech.glitter/grammar/sparql.jj,v $
 * Created by:  Lee Feigenbaum (<a href="mailto:feigenbl@us.ibm.com">feigenbl@us.ibm.com</a>) 
 * Created on: 10/23/06
 * Revision: $Id: sparql.jj 164 2007-07-31 14:11:09Z mroy $ 
 * 
 * Contributors: IBM Corporation - initial API and implementation 
 * Cambridge Semantics Incorporated - Fork to Anzo 
 *******************************************************************************/
package org.openanzo.glitter.syntax.concrete;
import org.openanzo.exceptions.ExceptionConstants;
import org.openanzo.glitter.exception.GlitterRuntimeException;
import org.openanzo.glitter.expression.aggregate.Min;
import org.openanzo.glitter.expression.aggregate.Max;
import org.openanzo.glitter.expression.aggregate.Count;
import org.openanzo.glitter.expression.aggregate.Sum;
import org.openanzo.glitter.expression.aggregate.Average;
import org.openanzo.glitter.expression.aggregate.Sample;
import org.openanzo.glitter.expression.aggregate.GroupConcat;
import org.openanzo.glitter.expression.Function;
import org.openanzo.glitter.expression.builtin.*;
import org.openanzo.glitter.util.Constants;
import org.openanzo.glitter.util.CURIE;
import org.openanzo.rdf.URI;
import org.openanzo.rdf.MemVariable;
import org.openanzo.rdf.Variable;
import org.openanzo.rdf.Literal;
import org.openanzo.rdf.TypedLiteral;
import org.openanzo.rdf.TriplePatternComponent;
import org.openanzo.glitter.syntax.abstrakt.*;
import org.openanzo.rdf.BlankNodeManager;
import org.openanzo.rdf.MemBlankNode;
import org.openanzo.rdf.datatype.*;
import org.openanzo.rdf.vocabulary.RDF;
import org.openanzo.glitter.query.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;
import java.util.HashMap;


// JavaCC generates code with compiler warnings that we can't get rid of so we suppress them.
@SuppressWarnings({"all"})
public class SPARQLParser extends SPARQLParserBase implements SPARQLParserConstants {

  final public void Query() throws ParseException {
        GraphPattern pattern = null;
    Prolog();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SELECT:
      pattern = SelectQuery(true);
      break;
    case CONSTRUCT:
      pattern = ConstructQuery();
      break;
    case DESCRIBE:
      pattern = DescribeQuery();
      break;
    case ASK:
      pattern = AskQuery();
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    getQueryController().setQueryPattern(pattern);
    jj_consume_token(0);
  }

  final public void Prolog() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BASE:
      BaseDecl();
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PREFIX:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
      PrefixDecl();
    }
  }

  final public void BaseDecl() throws ParseException {
        Token t;
    jj_consume_token(BASE);
    t = jj_consume_token(Q_IRI_REF);
    getQueryController().setBaseUri(getQueryController().resolveUri(token2uri(t)));
  }

  final public void PrefixDecl() throws ParseException {
        Token t;
        URI uri;
        CURIE curie;
    jj_consume_token(PREFIX);
    t = jj_consume_token(QNAME_NS);
    curie = new CURIE(t.image);
    t = jj_consume_token(Q_IRI_REF);
    uri = getQueryController().resolveUri(token2uri(t));
    getQueryController().mapPrefix(curie.getPrefix(), uri);
  }

  final public GraphPattern SelectQuery(boolean allowDataset) throws ParseException {
        Variable v;
        Expression e;
        ArrayList<Variable> groupByVars = new ArrayList<Variable>();
        GraphPattern pattern;
        ArrayList<Expression> expressions = new ArrayList<Expression>();
        ArrayList<Variable> vars = new ArrayList<Variable>();
        boolean distinct = false;
        boolean reduced = false;
        boolean selectStar = false;
        Projection p;
    jj_consume_token(SELECT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DISTINCT:
      jj_consume_token(DISTINCT);
                distinct = true;
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REDUCED:
      jj_consume_token(REDUCED);
               reduced = true;
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case VAR1:
    case VAR2:
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VAR1:
        case VAR2:
          v = Var();
            expressions.add(new SimpleExpression(v)); vars.add(v);
          break;
        case LPAREN:
          jj_consume_token(LPAREN);
          e = Expression();
          jj_consume_token(AS);
          v = Var();
          jj_consume_token(RPAREN);
            expressions.add(e); vars.add(v);
          break;
        default:
          jj_la1[5] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
        case VAR1:
        case VAR2:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_2;
        }
      }
      break;
    case STAR:
      jj_consume_token(STAR);
             selectStar = true;
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FROM:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_3;
      }
      DatasetClause();
                     if (!allowDataset) {if (true) throw new GlitterRuntimeException(ExceptionConstants.GLITTER.NO_DATASET_IN_SUBQUERY);}
    }
    pattern = WhereClause();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GROUP:
      groupByVars = GroupByClause();
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
    SolutionModifier();
        // handle SELECT *
        if (vars.isEmpty()) {
                vars.addAll(pattern.getReferencedVariables());
                for (Variable var : vars)
                        expressions.add(new SimpleExpression(var));
        }
        p = new Projection(expressions, vars, groupByVars, selectStar, distinct, reduced);
        getQueryController().setQueryResultForm(p);
        {if (true) return pattern;}
    throw new Error("Missing return statement in function");
  }

  final public GraphPattern ConstructQuery() throws ParseException {
        GraphPattern pattern;
        ArrayList<TriplePatternNode> template = new ArrayList<TriplePatternNode>();
        ArrayList<TriplePatternComponent> templateGraph = new ArrayList<TriplePatternComponent>();
        Construct c;
    jj_consume_token(CONSTRUCT);
    ConstructTemplate(template, templateGraph);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FROM:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_4;
      }
      DatasetClause();
    }
    pattern = WhereClause();
    SolutionModifier();
        c = new Construct(template, templateGraph);
        getQueryController().setQueryResultForm(c);
        {if (true) return pattern;}
    throw new Error("Missing return statement in function");
  }

  final public GraphPattern DescribeQuery() throws ParseException {
    jj_consume_token(DESCRIBE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Q_IRI_REF:
    case QNAME_NS:
    case QNAME:
    case VAR1:
    case VAR2:
      label_5:
      while (true) {
        VarOrIRIref();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Q_IRI_REF:
        case QNAME_NS:
        case QNAME:
        case VAR1:
        case VAR2:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_5;
        }
      }
      break;
    case STAR:
      jj_consume_token(STAR);
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FROM:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_6;
      }
      DatasetClause();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
    case LCURLY:
      WhereClause();
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    SolutionModifier();
    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public GraphPattern AskQuery() throws ParseException {
        GraphPattern pattern;
    jj_consume_token(ASK);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FROM:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_7;
      }
      DatasetClause();
    }
    pattern = WhereClause();
        getQueryController().setQueryResultForm(new Ask());
        {if (true) return pattern;}
    throw new Error("Missing return statement in function");
  }

  final public void DatasetClause() throws ParseException {
    jj_consume_token(FROM);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Q_IRI_REF:
    case QNAME_NS:
    case QNAME:
      DefaultGraphClause();
      break;
    case NAMED:
      NamedGraphClause();
      break;
    case DATASET:
      NamedDatasetClause();
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void DefaultGraphClause() throws ParseException {
        URI u;
    u = SourceSelector();
    getQueryController().getParsedQueryDataset().getDefaultGraphURIs().add(u);
  }

  final public void NamedGraphClause() throws ParseException {
        URI u;
    jj_consume_token(NAMED);
    u = SourceSelector();
    getQueryController().getParsedQueryDataset().getNamedGraphURIs().add(u);
  }

  final public void NamedDatasetClause() throws ParseException {
        URI u;
    jj_consume_token(DATASET);
    u = SourceSelector();
    getQueryController().getParsedQueryDataset().getNamedDatasetURIs().add(u);
  }

  final public URI SourceSelector() throws ParseException {
        URI iri;
    iri = IRIref();
    {if (true) return iri;}
    throw new Error("Missing return statement in function");
  }

  final public GraphPattern WhereClause() throws ParseException {
        GraphPattern pattern;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      jj_consume_token(WHERE);
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    pattern = GroupGraphPattern();
    {if (true) return pattern;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<Variable> GroupByClause() throws ParseException {
        Variable v;
        ArrayList vars = new ArrayList();
    jj_consume_token(GROUP);
    jj_consume_token(BY);
    label_8:
    while (true) {
      v = Var();
                  vars.add(v);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VAR1:
      case VAR2:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_8;
      }
    }
          {if (true) return vars;}
    throw new Error("Missing return statement in function");
  }

  final public void SolutionModifier() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ORDER:
      OrderClause();
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LIMIT:
    case OFFSET:
      LimitOffsetClauses();
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
  }

  final public void OrderClause() throws ParseException {
        OrderingCondition cond;
        QueryController qe;
    qe = getQueryController();
    jj_consume_token(ORDER);
    jj_consume_token(BY);
    label_9:
    while (true) {
      cond = OrderCondition();
      qe.addOrderingCondition(cond);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COUNT:
      case AVG:
      case SAMPLE:
      case SUM:
      case MIN:
      case MAX:
      case GROUP_CONCAT:
      case ASC:
      case DESC:
      case SAMETERM:
      case STR:
      case LANG:
      case LANGMATCHES:
      case DATATYPE:
      case BOUND:
      case ISIRI:
      case ISURI:
      case ISBLANK:
      case ISLITERAL:
      case REGEX:
      case LPAREN:
      case Q_IRI_REF:
      case QNAME_NS:
      case QNAME:
      case VAR1:
      case VAR2:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_9;
      }
    }
  }

  final public OrderingCondition OrderCondition() throws ParseException {
        boolean ascending = true;
        Expression cond;
        Variable v;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASC:
    case DESC:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASC:
        jj_consume_token(ASC);
        break;
      case DESC:
        jj_consume_token(DESC);
               ascending = false;
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      cond = BrackettedExpression();
      break;
    case COUNT:
    case AVG:
    case SAMPLE:
    case SUM:
    case MIN:
    case MAX:
    case GROUP_CONCAT:
    case SAMETERM:
    case STR:
    case LANG:
    case LANGMATCHES:
    case DATATYPE:
    case BOUND:
    case ISIRI:
    case ISURI:
    case ISBLANK:
    case ISLITERAL:
    case REGEX:
    case LPAREN:
    case Q_IRI_REF:
    case QNAME_NS:
    case QNAME:
    case VAR1:
    case VAR2:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Q_IRI_REF:
      case QNAME_NS:
      case QNAME:
        cond = FunctionCall();
        break;
      case COUNT:
      case AVG:
      case SAMPLE:
      case SUM:
      case MIN:
      case MAX:
      case GROUP_CONCAT:
      case SAMETERM:
      case STR:
      case LANG:
      case LANGMATCHES:
      case DATATYPE:
      case BOUND:
      case ISIRI:
      case ISURI:
      case ISBLANK:
      case ISLITERAL:
      case REGEX:
        cond = BuiltInCall();
        break;
      case VAR1:
      case VAR2:
        v = Var();
                                                              cond = new SimpleExpression(v);
        break;
      case LPAREN:
        cond = BrackettedExpression();
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return new OrderingCondition(cond, ascending);}
    throw new Error("Missing return statement in function");
  }

  final public void LimitOffsetClauses() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LIMIT:
      LimitClause();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OFFSET:
        OffsetClause();
        break;
      default:
        jj_la1[25] = jj_gen;
        ;
      }
      break;
    case OFFSET:
      OffsetClause();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LIMIT:
        LimitClause();
        break;
      default:
        jj_la1[26] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void LimitClause() throws ParseException {
        Token t;
    jj_consume_token(LIMIT);
    t = jj_consume_token(INTEGER);
    getQueryController().setLimit(Integer.decode(t.image));
  }

  final public void OffsetClause() throws ParseException {
        Token t;
    jj_consume_token(OFFSET);
    t = jj_consume_token(INTEGER);
    getQueryController().setOffset(Integer.decode(t.image));
  }

  final public Group GroupGraphPattern() throws ParseException {
        Group g;
    jj_consume_token(LCURLY);
    g = GroupGraphPatternInsideCurlies();
    jj_consume_token(RCURLY);
    {if (true) return g;}
    throw new Error("Missing return statement in function");
  }

  final public Group GroupGraphPatternInsideCurlies() throws ParseException {
        Group g;
    enterGroupScope();
    g = GroupElement(null);
    exitGroupScope();
    {if (true) return g;}
    throw new Error("Missing return statement in function");
  }

  final public GraphPattern GroupOrSubqueryGraphPattern() throws ParseException {
        GraphPattern gp;
    jj_consume_token(LCURLY);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SELECT:
      gp = SelectSubqueryGraphPattern();
      break;
    default:
      jj_la1[28] = jj_gen;
      gp = GroupGraphPatternInsideCurlies();
    }
    jj_consume_token(RCURLY);
          {if (true) return gp;}
    throw new Error("Missing return statement in function");
  }

  final public Subquery SelectSubqueryGraphPattern() throws ParseException {
        GraphPattern pattern;
        SubqueryController sqc;
          sqc = enterSubquery();
    pattern = SelectQuery(false);
          sqc.setQueryPattern(pattern);
          exitSubquery();
          {if (true) return new Subquery(sqc);}
    throw new Error("Missing return statement in function");
  }

  final public Group GroupElement(Group g) throws ParseException {
        Group ggp;
    if (g == null) g = new Group();
    GraphPattern(g);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPTIONAL:
      ggp = OptionalGraphPattern();
                                   g.replaceCurrentContentsWithOptional(ggp);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
      GroupElement(g);
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
    {if (true) return g;}
    throw new Error("Missing return statement in function");
  }

// this returns void because all patterns reached from this point
// are added to the arraylist (which usually percolates up to
// GroupElement)
  final public void GraphPattern(Group g) throws ParseException {
        GraphPattern gp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
    case FALSE:
    case LBRACKET:
    case LPAREN:
    case PLUS:
    case MINUS:
    case Q_IRI_REF:
    case QNAME_NS:
    case QNAME:
    case BLANK_NODE_LABEL:
    case VAR1:
    case VAR2:
    case INTEGER:
    case DECIMAL:
    case DOUBLE:
    case STRING_LITERAL1:
    case STRING_LITERAL2:
    case STRING_LITERAL_LONG1:
    case STRING_LITERAL_LONG2:
    case NIL:
    case ANON:
      gp = BasicGraphPattern();
                               if (gp != null) g.addGraphPattern(gp);
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GRAPH:
    case FILTER:
    case LET:
    case LCURLY:
      gp = GraphPatternNotTriples(g);
                                     if (gp != null) g.addGraphPattern(gp);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        break;
      default:
        jj_la1[32] = jj_gen;
        ;
      }
      GraphPattern(g);
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
  }

  final public BGP BasicGraphPattern() throws ParseException {
        BGP bgp = null;
    bgp = BlockOfTriples();
    {if (true) return bgp;}

    throw new Error("Missing return statement in function");
  }

  final public BGP BlockOfTriples() throws ParseException {
        ArrayList<TriplePatternNode> triples = new ArrayList<TriplePatternNode>();
    TriplesSameSubject(triples);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        ;
        break;
      default:
        jj_la1[34] = jj_gen;
        break label_10;
      }
      jj_consume_token(DOT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRUE:
      case FALSE:
      case LBRACKET:
      case LPAREN:
      case PLUS:
      case MINUS:
      case Q_IRI_REF:
      case QNAME_NS:
      case QNAME:
      case BLANK_NODE_LABEL:
      case VAR1:
      case VAR2:
      case INTEGER:
      case DECIMAL:
      case DOUBLE:
      case STRING_LITERAL1:
      case STRING_LITERAL2:
      case STRING_LITERAL_LONG1:
      case STRING_LITERAL_LONG2:
      case NIL:
      case ANON:
        TriplesSameSubject(triples);
        break;
      default:
        jj_la1[35] = jj_gen;
        ;
      }
    }
    {if (true) return new BGP(triples);}
    throw new Error("Missing return statement in function");
  }

// The return value can be null if this only matches a constraint
  final public GraphPattern GraphPatternNotTriples(Group g) throws ParseException {
        GraphPattern gp;
        Expression e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LCURLY:
      gp = GroupOrUnionGraphPattern();
                                     {if (true) return gp;}
      break;
    case GRAPH:
      gp = GraphGraphPattern();
                              {if (true) return gp;}
      break;
    case FILTER:
      e = Constraint();
                      g.addFilter(e); {if (true) return null;}
      break;
    case LET:
      LetGraphPattern(g);
                        {if (true) return null;}
      break;
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void LetGraphPattern(Group g) throws ParseException {
    jj_consume_token(LET);
    jj_consume_token(LPAREN);
    Assignment(g);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        ;
        break;
      default:
        jj_la1[37] = jj_gen;
        break label_11;
      }
      jj_consume_token(DOT);
      Assignment(g);
    }
    jj_consume_token(RPAREN);
  }

  final public void Assignment(Group g) throws ParseException {
        Variable v;
        Expression e;
    v = Var();
    jj_consume_token(ASSIGN);
    e = Expression();
            g.addAssignment(v, e);
  }

  final public Group OptionalGraphPattern() throws ParseException {
        Group g;
    jj_consume_token(OPTIONAL);
    g = GroupGraphPattern();
    {if (true) return g;}
    throw new Error("Missing return statement in function");
  }

  final public Graph GraphGraphPattern() throws ParseException {
        TriplePatternComponent g;
        GraphPattern gp;
    jj_consume_token(GRAPH);
    g = VarOrIRIref();
    gp = GroupGraphPattern();
    {if (true) return new Graph(g, gp);}
    throw new Error("Missing return statement in function");
  }

  final public GraphPattern GroupOrUnionGraphPattern() throws ParseException {
        GraphPattern lhs, rhs;
    lhs = GroupOrSubqueryGraphPattern();
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNION:
        ;
        break;
      default:
        jj_la1[38] = jj_gen;
        break label_12;
      }
      jj_consume_token(UNION);
      rhs = GroupOrSubqueryGraphPattern();
      lhs = new Union(lhs, rhs);
    }
    {if (true) return lhs;}
    throw new Error("Missing return statement in function");
  }

  final public Expression Constraint() throws ParseException {
        Expression e;
    jj_consume_token(FILTER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      e = BrackettedExpression();
      break;
    case COUNT:
    case AVG:
    case SAMPLE:
    case SUM:
    case MIN:
    case MAX:
    case GROUP_CONCAT:
    case SAMETERM:
    case STR:
    case LANG:
    case LANGMATCHES:
    case DATATYPE:
    case BOUND:
    case ISIRI:
    case ISURI:
    case ISBLANK:
    case ISLITERAL:
    case REGEX:
      e = BuiltInCall();
      break;
    case Q_IRI_REF:
    case QNAME_NS:
    case QNAME:
      e = FunctionCall();
      break;
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public Expression FunctionCall() throws ParseException {
        URI u;
        List<Expression> args;
        boolean distinct = false;
        boolean star = false;
    u = IRIref();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NIL:
      jj_consume_token(NIL);
            args = new ArrayList<Expression>();
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DISTINCT:
        jj_consume_token(DISTINCT);
                   distinct = true;
        break;
      default:
        jj_la1[40] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        jj_consume_token(STAR);
               star = true; args = new ArrayList<Expression>();
        break;
      case COUNT:
      case AVG:
      case SAMPLE:
      case SUM:
      case MIN:
      case MAX:
      case GROUP_CONCAT:
      case SAMETERM:
      case STR:
      case LANG:
      case LANGMATCHES:
      case DATATYPE:
      case BOUND:
      case ISIRI:
      case ISURI:
      case ISBLANK:
      case ISLITERAL:
      case REGEX:
      case TRUE:
      case FALSE:
      case LPAREN:
      case PLUS:
      case MINUS:
      case NOT:
      case Q_IRI_REF:
      case QNAME_NS:
      case QNAME:
      case VAR1:
      case VAR2:
      case INTEGER:
      case DECIMAL:
      case DOUBLE:
      case STRING_LITERAL1:
      case STRING_LITERAL2:
      case STRING_LITERAL_LONG1:
      case STRING_LITERAL_LONG2:
        args = ArgList();
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return new FunctionCall(u, args, star, distinct);} // can throw UnknownFunctionException

    throw new Error("Missing return statement in function");
  }

  final public List<Expression> ArgList() throws ParseException {
        ArrayList<Expression> args = new ArrayList<Expression>();
        Expression e;
    e = Expression();
                           args.add(e);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[43] = jj_gen;
        break label_13;
      }
      jj_consume_token(COMMA);
      e = Expression();
                             args.add(e);
    }
    {if (true) return args;}
    throw new Error("Missing return statement in function");
  }

  final public void ConstructTemplate(ArrayList<TriplePatternNode> triples, ArrayList<TriplePatternComponent> quadComponent) throws ParseException {
    jj_consume_token(LCURLY);
    ConstructTemplateContents(triples, quadComponent);
    jj_consume_token(RCURLY);
  }

  final public void ConstructTemplateContents(ArrayList<TriplePatternNode> triples, ArrayList<TriplePatternComponent> quadComponent) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GRAPH:
      ConstructGraphTriples(triples, quadComponent);
      ConstructTemplateContents(triples, quadComponent);
      break;
    default:
      jj_la1[45] = jj_gen;
      ConstructTriples(triples, quadComponent, null);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        ConstructTemplateContents(triples, quadComponent);
        break;
      default:
        jj_la1[44] = jj_gen;
        ;
      }
    }
  }

  final public void ConstructTriples(ArrayList<TriplePatternNode> triples, ArrayList<TriplePatternComponent> quadComponent, TriplePatternComponent graph) throws ParseException {
        int beginSize = triples.size();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
    case FALSE:
    case LBRACKET:
    case LPAREN:
    case PLUS:
    case MINUS:
    case Q_IRI_REF:
    case QNAME_NS:
    case QNAME:
    case BLANK_NODE_LABEL:
    case VAR1:
    case VAR2:
    case INTEGER:
    case DECIMAL:
    case DOUBLE:
    case STRING_LITERAL1:
    case STRING_LITERAL2:
    case STRING_LITERAL_LONG1:
    case STRING_LITERAL_LONG2:
    case NIL:
    case ANON:
      TriplesSameSubject(triples);
      break;
    default:
      jj_la1[46] = jj_gen;
      ;
    }
        // mark down that all these new triples we just collected belong to the given graph component
    for (int i = beginSize; i < triples.size(); i++) {
        quadComponent.add(graph);
    }
  }

  final public void ConstructGraphTriples(ArrayList<TriplePatternNode> triples, ArrayList<TriplePatternComponent> quadComponent) throws ParseException {
        TriplePatternComponent g;
    jj_consume_token(GRAPH);
    g = VarOrIRIref();
    jj_consume_token(LCURLY);
    ConstructTriples(triples, quadComponent, g);
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        ;
        break;
      default:
        jj_la1[47] = jj_gen;
        break label_14;
      }
      jj_consume_token(DOT);
      ConstructTriples(triples, quadComponent, g);
    }
    jj_consume_token(RCURLY);
  }

  final public void TriplesSameSubject(ArrayList<TriplePatternNode> accumulatedTriples) throws ParseException {
        TriplePatternComponent s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
    case FALSE:
    case PLUS:
    case MINUS:
    case Q_IRI_REF:
    case QNAME_NS:
    case QNAME:
    case BLANK_NODE_LABEL:
    case VAR1:
    case VAR2:
    case INTEGER:
    case DECIMAL:
    case DOUBLE:
    case STRING_LITERAL1:
    case STRING_LITERAL2:
    case STRING_LITERAL_LONG1:
    case STRING_LITERAL_LONG2:
    case NIL:
    case ANON:
      s = VarOrTerm();
      PropertyListNotEmpty(s, accumulatedTriples);
      break;
    case LBRACKET:
    case LPAREN:
      s = TriplesNode(accumulatedTriples);
      PropertyList(s, accumulatedTriples);
      break;
    default:
      jj_la1[48] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void PropertyList(TriplePatternComponent s, ArrayList<TriplePatternNode> accumulatedTriples) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A:
    case Q_IRI_REF:
    case QNAME_NS:
    case QNAME:
    case VAR1:
    case VAR2:
      PropertyListNotEmpty(s, accumulatedTriples);
      break;
    default:
      jj_la1[49] = jj_gen;
      ;
    }
  }

  final public void PropertyListNotEmpty(TriplePatternComponent s, ArrayList<TriplePatternNode>  accumulatedTriples) throws ParseException {
        TriplePatternComponent p;
    p = Verb();
    ObjectList(s, p, accumulatedTriples);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMIC:
      jj_consume_token(SEMIC);
      PropertyList(s, accumulatedTriples);
      break;
    default:
      jj_la1[50] = jj_gen;
      ;
    }
  }

  final public void ObjectList(TriplePatternComponent s, TriplePatternComponent p, ArrayList<TriplePatternNode> accumulatedTriples) throws ParseException {
        TriplePatternComponent o;
    o = GraphNode(accumulatedTriples);
    accumulatedTriples.add(new TriplePatternNode(s, p, o));
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      ObjectList(s, p, accumulatedTriples);
      break;
    default:
      jj_la1[51] = jj_gen;
      ;
    }
  }

  final public TriplePatternComponent Verb() throws ParseException {
        TriplePatternComponent node;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Q_IRI_REF:
    case QNAME_NS:
    case QNAME:
    case VAR1:
    case VAR2:
      node = VarOrIRIref();
                         {if (true) return node;}
      break;
    case A:
      jj_consume_token(A);
        {if (true) return RDF.TYPE;}
      break;
    default:
      jj_la1[52] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public TriplePatternComponent TriplesNode(ArrayList<TriplePatternNode> accumulatedTriples) throws ParseException {
        TriplePatternComponent node;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      node = Collection(accumulatedTriples);
                                          {if (true) return node;}
      break;
    case LBRACKET:
      node = BlankNodePropertyList(accumulatedTriples);
                                                     {if (true) return node;}
      break;
    default:
      jj_la1[53] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public TriplePatternComponent BlankNodePropertyList(ArrayList<TriplePatternNode> accumulatedTriples) throws ParseException {
        org.openanzo.rdf.BlankNode bnode;
    bnode = getBlankNodeManager().getBlankNode();
    jj_consume_token(LBRACKET);
    PropertyListNotEmpty(bnode, accumulatedTriples);
    jj_consume_token(RBRACKET);
    {if (true) return bnode;}
    throw new Error("Missing return statement in function");
  }

  final public TriplePatternComponent Collection(ArrayList<TriplePatternNode> accumulatedTriples) throws ParseException {
        ArrayList<TriplePatternComponent> listNodes = new ArrayList<TriplePatternComponent>();
        TriplePatternComponent node;
    jj_consume_token(LPAREN);
    label_15:
    while (true) {
      node = GraphNode(accumulatedTriples);
                                           listNodes.add(node);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRUE:
      case FALSE:
      case LBRACKET:
      case LPAREN:
      case PLUS:
      case MINUS:
      case Q_IRI_REF:
      case QNAME_NS:
      case QNAME:
      case BLANK_NODE_LABEL:
      case VAR1:
      case VAR2:
      case INTEGER:
      case DECIMAL:
      case DOUBLE:
      case STRING_LITERAL1:
      case STRING_LITERAL2:
      case STRING_LITERAL_LONG1:
      case STRING_LITERAL_LONG2:
      case NIL:
      case ANON:
        ;
        break;
      default:
        jj_la1[54] = jj_gen;
        break label_15;
      }
    }
    jj_consume_token(RPAREN);
        {if (true) return nodes2collection(listNodes, accumulatedTriples);}
    throw new Error("Missing return statement in function");
  }

  final public TriplePatternComponent GraphNode(ArrayList<TriplePatternNode> accumulatedTriples) throws ParseException {
        TriplePatternComponent node;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
    case FALSE:
    case PLUS:
    case MINUS:
    case Q_IRI_REF:
    case QNAME_NS:
    case QNAME:
    case BLANK_NODE_LABEL:
    case VAR1:
    case VAR2:
    case INTEGER:
    case DECIMAL:
    case DOUBLE:
    case STRING_LITERAL1:
    case STRING_LITERAL2:
    case STRING_LITERAL_LONG1:
    case STRING_LITERAL_LONG2:
    case NIL:
    case ANON:
      node = VarOrTerm();
                       {if (true) return node;}
      break;
    case LBRACKET:
    case LPAREN:
      node = TriplesNode(accumulatedTriples);
                                           {if (true) return node;}
      break;
    default:
      jj_la1[55] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public TriplePatternComponent VarOrTerm() throws ParseException {
        TriplePatternComponent node;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VAR1:
    case VAR2:
      node = Var();
                 {if (true) return node;}
      break;
    case TRUE:
    case FALSE:
    case PLUS:
    case MINUS:
    case Q_IRI_REF:
    case QNAME_NS:
    case QNAME:
    case BLANK_NODE_LABEL:
    case INTEGER:
    case DECIMAL:
    case DOUBLE:
    case STRING_LITERAL1:
    case STRING_LITERAL2:
    case STRING_LITERAL_LONG1:
    case STRING_LITERAL_LONG2:
    case NIL:
    case ANON:
      node = GraphTerm();
                       {if (true) return node;}
      break;
    default:
      jj_la1[56] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public TriplePatternComponent VarOrIRIref() throws ParseException {
        Variable v;
        URI u;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VAR1:
    case VAR2:
      v = Var();
                                  {if (true) return v;}
      break;
    case Q_IRI_REF:
    case QNAME_NS:
    case QNAME:
      u = IRIref();
                                  {if (true) return u;}
      break;
    default:
      jj_la1[57] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public TriplePatternComponent VarOrBlankNodeOrIRIref() throws ParseException {
        Variable v;
        org.openanzo.rdf.BlankNode bnode;
        URI u;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VAR1:
    case VAR2:
      v = Var();
                                  {if (true) return v;}
      break;
    case BLANK_NODE_LABEL:
    case ANON:
      bnode = BlankNode();
                          {if (true) return bnode;}
      break;
    case Q_IRI_REF:
    case QNAME_NS:
    case QNAME:
      u = IRIref();
                                  {if (true) return u;}
      break;
    default:
      jj_la1[58] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Variable Var() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VAR1:
      t = jj_consume_token(VAR1);
      break;
    case VAR2:
      t = jj_consume_token(VAR2);
      break;
    default:
      jj_la1[59] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return getVariable(t.image.substring(1));}
    throw new Error("Missing return statement in function");
  }

  final public TriplePatternComponent GraphTerm() throws ParseException {
        //TriplePatternComponent n;
        URI u;
        TypedLiteral tl;
        Literal lit;
        org.openanzo.rdf.BlankNode bnode;
        Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Q_IRI_REF:
    case QNAME_NS:
    case QNAME:
      u = IRIref();
                 {if (true) return u;}
      break;
    case STRING_LITERAL1:
    case STRING_LITERAL2:
    case STRING_LITERAL_LONG1:
    case STRING_LITERAL_LONG2:
      lit = RDFLiteral();
                       {if (true) return lit;}
      break;
    case PLUS:
    case MINUS:
    case INTEGER:
    case DECIMAL:
    case DOUBLE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          t = jj_consume_token(MINUS);
          break;
        case PLUS:
          t = jj_consume_token(PLUS);
          break;
        default:
          jj_la1[60] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[61] = jj_gen;
        ;
      }
      tl = NumericLiteral(t != null ? t.image : "");
        {if (true) return tl;}
      break;
    case TRUE:
    case FALSE:
      tl = BooleanLiteral();
                          {if (true) return tl;}
      break;
    case BLANK_NODE_LABEL:
    case ANON:
      bnode = BlankNode();
                        {if (true) return bnode;}
      break;
    case NIL:
      jj_consume_token(NIL);
          {if (true) return nodes2collection(new ArrayList<TriplePatternComponent>());}
      break;
    default:
      jj_la1[62] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Expression Expression() throws ParseException {
  Expression e;
    e = ConditionalOrExpression();
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public Expression ConditionalOrExpression() throws ParseException {
  Expression arg1, arg2;
  ArrayList<Expression> args;
    arg1 = ConditionalAndExpression();
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[63] = jj_gen;
        break label_16;
      }
      jj_consume_token(OR);
      arg2 = ConditionalAndExpression();
      args = new ArrayList<Expression>();
      args.add(arg1);
      args.add(arg2);
      arg1 = new FunctionCall(new LogicalOr(), args);
    }
    {if (true) return arg1;}
    throw new Error("Missing return statement in function");
  }

  final public Expression ConditionalAndExpression() throws ParseException {
  Expression arg1, arg2;
  ArrayList<Expression> args;
    arg1 = ValueLogical();
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[64] = jj_gen;
        break label_17;
      }
      jj_consume_token(AND);
      arg2 = ValueLogical();
      args = new ArrayList<Expression>();
      args.add(arg1);
      args.add(arg2);
      arg1 = new FunctionCall(new LogicalAnd(), args);
    }
    {if (true) return arg1;}
    throw new Error("Missing return statement in function");
  }

  final public Expression ValueLogical() throws ParseException {
  Expression e;
    e = RelationalExpression();
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public Expression RelationalExpression() throws ParseException {
  Expression arg1, arg2 = null;
  Function f = null;
  ArrayList<Expression> args = new ArrayList<Expression>();
    arg1 = NumericExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQ:
      jj_consume_token(EQ);
      arg2 = NumericExpression();
                                      f = new PolymorphicEq();
      break;
    case NE:
      jj_consume_token(NE);
      arg2 = NumericExpression();
                                      f = new PolymorphicNe();
      break;
    case LT:
      jj_consume_token(LT);
      arg2 = NumericExpression();
                                      f = new PolymorphicLt();
      break;
    case GT:
      jj_consume_token(GT);
      arg2 = NumericExpression();
                                      f = new PolymorphicGt();
      break;
    case LE:
      jj_consume_token(LE);
      arg2 = NumericExpression();
                                      f = new PolymorphicLe();
      break;
    case GE:
      jj_consume_token(GE);
      arg2 = NumericExpression();
                                      f = new PolymorphicGe();
      break;
    default:
      jj_la1[67] = jj_gen;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IN:
        jj_consume_token(IN);
                       args.add(arg1);
        jj_consume_token(LPAREN);
        arg2 = PrimaryExpression();
                                             args.add(arg2);
        label_18:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[65] = jj_gen;
            break label_18;
          }
          jj_consume_token(COMMA);
          arg2 = PrimaryExpression();
                                               args.add(arg2);
        }
        jj_consume_token(RPAREN);
                 {if (true) return new FunctionCall(new In(),args);}
        break;
      default:
        jj_la1[66] = jj_gen;
        ;
      }
    }
        if (arg2 == null) {if (true) return arg1;}
        args.add(arg1);
        args.add(arg2);
        {if (true) return new FunctionCall(f, args);}
    throw new Error("Missing return statement in function");
  }

  final public Expression NumericExpression() throws ParseException {
  Expression e;
    e = AdditiveExpression();
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public Expression AdditiveExpression() throws ParseException {
        Expression arg1, arg2;
        ArrayList<Expression> args;//
        Function f;
    arg1 = MultiplicativeExpression();
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[68] = jj_gen;
        break label_19;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        jj_consume_token(PLUS);
        arg2 = MultiplicativeExpression();
                                               f = new PolymorphicAdd();
        break;
      case MINUS:
        jj_consume_token(MINUS);
        arg2 = MultiplicativeExpression();
                                                f = new PolymorphicSubtract();
        break;
      default:
        jj_la1[69] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
         args = new ArrayList<Expression>();
         args.add(arg1);
         args.add(arg2);
     arg1 = new FunctionCall(f, args);
    }
    {if (true) return arg1;}
    throw new Error("Missing return statement in function");
  }

  final public Expression MultiplicativeExpression() throws ParseException {
        Expression arg1, arg2;
        ArrayList<Expression> args;//
        Function f;
    arg1 = UnaryExpression();
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
      case SLASH:
        ;
        break;
      default:
        jj_la1[70] = jj_gen;
        break label_20;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        jj_consume_token(STAR);
        arg2 = UnaryExpression();
                                      f = new NumericMultiply();
        break;
      case SLASH:
        jj_consume_token(SLASH);
        arg2 = UnaryExpression();
                                       f = new NumericDivide();
        break;
      default:
        jj_la1[71] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
         args = new ArrayList<Expression>();
         args.add(arg1);
         args.add(arg2);
     arg1 = new FunctionCall(f, args);
    }
    {if (true) return arg1;}
    throw new Error("Missing return statement in function");
  }

  final public Expression UnaryExpression() throws ParseException {
        Expression e;
        ArrayList<Expression> args = new ArrayList<Expression>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
      e = PrimaryExpression();
                                        args.add(e); {if (true) return new FunctionCall(new Not(), args);}
      break;
    case PLUS:
      jj_consume_token(PLUS);
      e = PrimaryExpression();
                                         args.add(e); {if (true) return new FunctionCall(new UnaryPlus(), args);}
      break;
    case MINUS:
      jj_consume_token(MINUS);
      e = PrimaryExpression();
                                          args.add(e); {if (true) return new FunctionCall(new UnaryMinus(), args);}
      break;
    case COUNT:
    case AVG:
    case SAMPLE:
    case SUM:
    case MIN:
    case MAX:
    case GROUP_CONCAT:
    case SAMETERM:
    case STR:
    case LANG:
    case LANGMATCHES:
    case DATATYPE:
    case BOUND:
    case ISIRI:
    case ISURI:
    case ISBLANK:
    case ISLITERAL:
    case REGEX:
    case TRUE:
    case FALSE:
    case LPAREN:
    case Q_IRI_REF:
    case QNAME_NS:
    case QNAME:
    case VAR1:
    case VAR2:
    case INTEGER:
    case DECIMAL:
    case DOUBLE:
    case STRING_LITERAL1:
    case STRING_LITERAL2:
    case STRING_LITERAL_LONG1:
    case STRING_LITERAL_LONG2:
      e = PrimaryExpression();
                                  {if (true) return e;}
      break;
    default:
      jj_la1[72] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Expression PrimaryExpression() throws ParseException {
  Expression e = null;
  TriplePatternComponent tpc = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      e = BrackettedExpression();
      break;
    case COUNT:
    case AVG:
    case SAMPLE:
    case SUM:
    case MIN:
    case MAX:
    case GROUP_CONCAT:
    case SAMETERM:
    case STR:
    case LANG:
    case LANGMATCHES:
    case DATATYPE:
    case BOUND:
    case ISIRI:
    case ISURI:
    case ISBLANK:
    case ISLITERAL:
    case REGEX:
      e = BuiltInCall();
      break;
    case Q_IRI_REF:
    case QNAME_NS:
    case QNAME:
      e = IRIrefOrFunction();
      break;
    case STRING_LITERAL1:
    case STRING_LITERAL2:
    case STRING_LITERAL_LONG1:
    case STRING_LITERAL_LONG2:
      tpc = RDFLiteral();
      break;
    case INTEGER:
    case DECIMAL:
    case DOUBLE:
      tpc = NumericLiteral("");
      break;
    case TRUE:
    case FALSE:
      tpc = BooleanLiteral();
      break;
    case VAR1:
    case VAR2:
      tpc = Var();
      break;
    default:
      jj_la1[73] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        if (e == null) e = new SimpleExpression(tpc);
        {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public Expression BrackettedExpression() throws ParseException {
  Expression e;
    jj_consume_token(LPAREN);
    e = Expression();
    jj_consume_token(RPAREN);
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public FunctionCall BuiltInCall() throws ParseException {
        Variable v;
        Expression e;
        ArrayList<Expression> args = new ArrayList<Expression>();
        FunctionCall fc;
        boolean distinct = false;
        boolean star = false;
        HashMap<String, Object> attributes;
        String s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SAMETERM:
      jj_consume_token(SAMETERM);
      jj_consume_token(LPAREN);
      e = Expression();
                             args.add(e);
      jj_consume_token(COMMA);
      e = Expression();
                             args.add(e);
      jj_consume_token(RPAREN);
            {if (true) return new FunctionCall(new SameTerm(), args);}
      break;
    case STR:
      jj_consume_token(STR);
      jj_consume_token(LPAREN);
      e = Expression();
                             args.add(e);
      jj_consume_token(RPAREN);
            {if (true) return new FunctionCall(new Str(), args);}
      break;
    case LANG:
      jj_consume_token(LANG);
      jj_consume_token(LPAREN);
      e = Expression();
                             args.add(e);
      jj_consume_token(RPAREN);
            {if (true) return new FunctionCall(new Lang(), args);}
      break;
    case LANGMATCHES:
      jj_consume_token(LANGMATCHES);
      jj_consume_token(LPAREN);
      e = Expression();
                             args.add(e);
      jj_consume_token(COMMA);
      e = Expression();
                             args.add(e);
      jj_consume_token(RPAREN);
            {if (true) return new FunctionCall(new LangMatches(), args);}
      break;
    case DATATYPE:
      jj_consume_token(DATATYPE);
      jj_consume_token(LPAREN);
      e = Expression();
                             args.add(e);
      jj_consume_token(RPAREN);
            {if (true) return new FunctionCall(new Datatype(), args);}
      break;
    case BOUND:
      jj_consume_token(BOUND);
      jj_consume_token(LPAREN);
      v = Var();
                      args.add(new SimpleExpression(v));
      jj_consume_token(RPAREN);
            {if (true) return new FunctionCall(new Bound(), args);}
      break;
    case ISIRI:
      jj_consume_token(ISIRI);
      jj_consume_token(LPAREN);
      e = Expression();
                             args.add(e);
      jj_consume_token(RPAREN);
            {if (true) return new FunctionCall(new IsIRI(), args);}
      break;
    case ISURI:
      jj_consume_token(ISURI);
      jj_consume_token(LPAREN);
      e = Expression();
                             args.add(e);
      jj_consume_token(RPAREN);
            {if (true) return new FunctionCall(new IsIRI(), args);}
      break;
    case ISBLANK:
      jj_consume_token(ISBLANK);
      jj_consume_token(LPAREN);
      e = Expression();
                             args.add(e);
      jj_consume_token(RPAREN);
            {if (true) return new FunctionCall(new IsBlank(), args);}
      break;
    case ISLITERAL:
      jj_consume_token(ISLITERAL);
      jj_consume_token(LPAREN);
      e = Expression();
                             args.add(e);
      jj_consume_token(RPAREN);
            {if (true) return new FunctionCall(new IsLiteral(), args);}
      break;
    case REGEX:
      fc = RegexExpression();
          {if (true) return fc;}
      break;
    case COUNT:
      jj_consume_token(COUNT);
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DISTINCT:
        jj_consume_token(DISTINCT);
                   distinct = true;
        break;
      default:
        jj_la1[74] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        jj_consume_token(STAR);
               star = true;
        break;
      case VAR1:
      case VAR2:
        v = Var();
                        args.add(new SimpleExpression(v));
        label_21:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[75] = jj_gen;
            break label_21;
          }
          jj_consume_token(COMMA);
          v = Var();
                          args.add(new SimpleExpression(v));
        }
        break;
      default:
        jj_la1[76] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RPAREN);
      {if (true) return new FunctionCall(new Count(), args, star, distinct);}
      break;
    case SUM:
      jj_consume_token(SUM);
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DISTINCT:
        jj_consume_token(DISTINCT);
                   distinct = true;
        break;
      default:
        jj_la1[77] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        jj_consume_token(STAR);
               star = true;
        break;
      case VAR1:
      case VAR2:
        v = Var();
                        args.add(new SimpleExpression(v));
        label_22:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[78] = jj_gen;
            break label_22;
          }
          jj_consume_token(COMMA);
          v = Var();
                          args.add(new SimpleExpression(v));
        }
        break;
      default:
        jj_la1[79] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RPAREN);
      {if (true) return new FunctionCall(new Sum(), args, star, distinct);}
      break;
    case AVG:
      jj_consume_token(AVG);
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DISTINCT:
        jj_consume_token(DISTINCT);
                   distinct = true;
        break;
      default:
        jj_la1[80] = jj_gen;
        ;
      }
      v = Var();
                args.add(new SimpleExpression(v));
      jj_consume_token(RPAREN);
      {if (true) return new FunctionCall(new Average(), args, star, distinct);}
      break;
    case SAMPLE:
      jj_consume_token(SAMPLE);
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DISTINCT:
        jj_consume_token(DISTINCT);
                   distinct = true;
        break;
      default:
        jj_la1[81] = jj_gen;
        ;
      }
      v = Var();
                args.add(new SimpleExpression(v));
      jj_consume_token(RPAREN);
      {if (true) return new FunctionCall(new Sample(), args, star, distinct);}
      break;
    case MIN:
      jj_consume_token(MIN);
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DISTINCT:
        jj_consume_token(DISTINCT);
                   distinct = true;
        break;
      default:
        jj_la1[82] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        jj_consume_token(STAR);
               star = true;
        break;
      case VAR1:
      case VAR2:
        v = Var();
                        args.add(new SimpleExpression(v));
        label_23:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[83] = jj_gen;
            break label_23;
          }
          jj_consume_token(COMMA);
          v = Var();
                          args.add(new SimpleExpression(v));
        }
        break;
      default:
        jj_la1[84] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RPAREN);
      {if (true) return new FunctionCall(new Min(), args, star, distinct);}
      break;
    case MAX:
      jj_consume_token(MAX);
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DISTINCT:
        jj_consume_token(DISTINCT);
                   distinct = true;
        break;
      default:
        jj_la1[85] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        jj_consume_token(STAR);
               star = true;
        break;
      case VAR1:
      case VAR2:
        v = Var();
                        args.add(new SimpleExpression(v));
        label_24:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[86] = jj_gen;
            break label_24;
          }
          jj_consume_token(COMMA);
          v = Var();
                          args.add(new SimpleExpression(v));
        }
        break;
      default:
        jj_la1[87] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RPAREN);
      {if (true) return new FunctionCall(new Max(), args, star, distinct);}
      break;
    case GROUP_CONCAT:
      jj_consume_token(GROUP_CONCAT);
                     attributes = new HashMap<String, Object>();
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DISTINCT:
        jj_consume_token(DISTINCT);
                   distinct = true;
        break;
      default:
        jj_la1[88] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        jj_consume_token(STAR);
               star = true;
        break;
      case VAR1:
      case VAR2:
        v = Var();
                        args.add(new SimpleExpression(v));
        label_25:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[89] = jj_gen;
            break label_25;
          }
          jj_consume_token(COMMA);
          v = Var();
                          args.add(new SimpleExpression(v));
        }
        break;
      default:
        jj_la1[90] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEPARATOR:
        jj_consume_token(SEPARATOR);
        s = String();
                                 attributes.put(GroupConcat.ATTRIBUTE_SEPARATOR, s);
        break;
      default:
        jj_la1[91] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
      {if (true) return new FunctionCall(new GroupConcat(), args, star, distinct, attributes);}
      break;
    default:
      jj_la1[92] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public FunctionCall RegexExpression() throws ParseException {
        ArrayList<Expression> args = new ArrayList<Expression>();
        Expression e;
    jj_consume_token(REGEX);
    jj_consume_token(LPAREN);
    e = Expression();
                     args.add(e);
    jj_consume_token(COMMA);
    e = Expression();
                     args.add(e);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      e = Expression();
                       args.add(e);
      break;
    default:
      jj_la1[93] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
        {if (true) return new FunctionCall(new RegEx(), args);}
    throw new Error("Missing return statement in function");
  }

  final public Expression IRIrefOrFunction() throws ParseException {
        URI u;
        List<Expression> args = null;
        boolean distinct = false;
        boolean star = false;
    // TODO - an IRI ref. in an expression can either be the name of
            // a function or just a simple value
      u = IRIref();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case NIL:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NIL:
        jj_consume_token(NIL);
            args = new ArrayList<Expression>();
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DISTINCT:
          jj_consume_token(DISTINCT);
                   distinct = true;
          break;
        default:
          jj_la1[94] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STAR:
          jj_consume_token(STAR);
               star = true; args = new ArrayList<Expression>();
          break;
        case COUNT:
        case AVG:
        case SAMPLE:
        case SUM:
        case MIN:
        case MAX:
        case GROUP_CONCAT:
        case SAMETERM:
        case STR:
        case LANG:
        case LANGMATCHES:
        case DATATYPE:
        case BOUND:
        case ISIRI:
        case ISURI:
        case ISBLANK:
        case ISLITERAL:
        case REGEX:
        case TRUE:
        case FALSE:
        case LPAREN:
        case PLUS:
        case MINUS:
        case NOT:
        case Q_IRI_REF:
        case QNAME_NS:
        case QNAME:
        case VAR1:
        case VAR2:
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:
          args = ArgList();
          break;
        default:
          jj_la1[95] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[96] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[97] = jj_gen;
      ;
    }
        if (args == null)
                {if (true) return new SimpleExpression(u);}
        else
                {if (true) return new FunctionCall(u, args, star, distinct);}
    throw new Error("Missing return statement in function");
  }

  final public org.openanzo.rdf.Literal RDFLiteral() throws ParseException {
        String lexicalValue;
        Token t;
        URI dt;
    lexicalValue = String();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DATATYPEMARKER:
    case LANGTAG:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LANGTAG:
        t = jj_consume_token(LANGTAG);
                    {if (true) return org.openanzo.rdf.MemPlainLiteral.create(lexicalValue, t.image.substring(1));}
        break;
      case DATATYPEMARKER:
        jj_consume_token(DATATYPEMARKER);
        dt = IRIref();
        {if (true) return org.openanzo.rdf.MemTypedLiteral.create(lexicalValue, dt);}
        break;
      default:
        jj_la1[98] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[99] = jj_gen;
      ;
    }
    {if (true) return org.openanzo.rdf.MemPlainLiteral.create(lexicalValue);}
    throw new Error("Missing return statement in function");
  }

  final public org.openanzo.rdf.TypedLiteral NumericLiteral(String prefix) throws ParseException {
        Token t;
        String xsdType;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
      t = jj_consume_token(INTEGER);
                  xsdType = "integer";
      break;
    case DECIMAL:
      t = jj_consume_token(DECIMAL);
                  xsdType = "decimal";
      break;
    case DOUBLE:
      t = jj_consume_token(DOUBLE);
                  xsdType = "double";
      break;
    default:
      jj_la1[100] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return org.openanzo.rdf.MemTypedLiteral.create(prefix + t.image, createUri(TypeMaps.xsd(xsdType)));}
    throw new Error("Missing return statement in function");
  }

  final public org.openanzo.rdf.TypedLiteral BooleanLiteral() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      jj_consume_token(TRUE);
           {if (true) return org.openanzo.rdf.MemTypedLiteral.create("true", createUri(TypeMaps.xsd("boolean")));}
      break;
    case FALSE:
      jj_consume_token(FALSE);
            {if (true) return org.openanzo.rdf.MemTypedLiteral.create("false", createUri(TypeMaps.xsd("boolean")));}
      break;
    default:
      jj_la1[101] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String String() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL1:
      t = jj_consume_token(STRING_LITERAL1);
      break;
    case STRING_LITERAL2:
      t = jj_consume_token(STRING_LITERAL2);
      break;
    case STRING_LITERAL_LONG1:
      t = jj_consume_token(STRING_LITERAL_LONG1);
      break;
    case STRING_LITERAL_LONG2:
      t = jj_consume_token(STRING_LITERAL_LONG2);
      break;
    default:
      jj_la1[102] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return evaluateStringLiteral(t.image);}
    throw new Error("Missing return statement in function");
  }

  final public URI IRIref() throws ParseException {
        Token t;
        URI u;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Q_IRI_REF:
      t = jj_consume_token(Q_IRI_REF);
    {if (true) return getQueryController().resolveUri(token2uri(t));}
      break;
    case QNAME_NS:
    case QNAME:
      u = QName();
                {if (true) return u;}
      break;
    default:
      jj_la1[103] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public URI QName() throws ParseException {
        // TODO -- QName's, IRIRef's, variable names all allow
        // escapes -- but only for valid characters -- not sure
        // where to handle that
        Token t;
        //String qname, prefix, local;
        CURIE curie;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QNAME:
      t = jj_consume_token(QNAME);
      break;
    case QNAME_NS:
      t = jj_consume_token(QNAME_NS);
      break;
    default:
      jj_la1[104] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        curie = new CURIE(t.image);
        {if (true) return getQueryController().resolveQName(curie.getPrefix(), curie.getLocal());}
    throw new Error("Missing return statement in function");
  }

  final public org.openanzo.rdf.BlankNode BlankNode() throws ParseException {
        Token t;
        BlankNodeManager bnm = getBlankNodeManager();
        org.openanzo.rdf.BlankNode bnode;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BLANK_NODE_LABEL:
      t = jj_consume_token(BLANK_NODE_LABEL);
                  bnode = bnm.getBlankNode(t.image);
      break;
    case ANON:
      jj_consume_token(ANON);
                  bnode = bnm.getBlankNode();
      break;
    default:
      jj_la1[105] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return bnode;}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public SPARQLParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[106];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x700200,0x80,0x100,0x400,0x800,0x0,0x0,0x0,0x800000,0x0,0x800000,0x0,0x0,0x800000,0x4000000,0x800000,0x3000000,0x4000000,0x0,0x8000000,0x80000000,0x6007f000,0x60000000,0x7f000,0x6007f000,0x0,0x80000000,0x80000000,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f000,0x400,0x7f000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f000,0x7f000,0x400,0x0,0x0,0x400,0x0,0x0,0x400,0x400,0x400,0x0,0x0,0x400,0x0,0x0,0x400,0x0,0x0,0x80000,0x7f000,0x0,0x400,0x7f000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x20000000,0x20000000,0x20800000,0x0,0x40,0x0,0x0,0x800000,0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0x1,0x2003ff80,0x0,0x2003ff80,0x2003ff80,0x1,0x0,0x1,0x0,0x1000000,0x2,0x28180000,0x1000000,0x2000034,0x1000000,0x28180000,0x2000034,0x1000000,0x8,0x2003ff80,0x0,0x209bff80,0x20000000,0x0,0x1000000,0x4,0x28180000,0x1000000,0x28180000,0x400000,0x80000000,0x0,0x400000,0x28000000,0x28180000,0x28180000,0x180000,0x0,0x0,0x0,0x0,0x0,0x180000,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x800000,0x800000,0x201bff80,0x201bff80,0x0,0x0,0x800000,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0x800000,0x0,0x0,0x800000,0x0,0x3ff80,0x0,0x0,0x209bff80,0x20000000,0x20000000,0x0,0x0,0x0,0x180000,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x180000,0x180000,0x180000,0x0,0x0,0x0,0x1b8000,0x1b8000,0x0,0x0,0x0,0x38000,0x0,0x180000,0x0,0x0,0x1b8000,0x0,0x1b8000,0x1b8000,0x0,0x0,0x0,0x0,0x0,0x0,0xb81f8006,0x0,0x0,0x0,0xb81f8006,0x0,0x0,0x0,0x38000,0x0,0xb81b9006,0x0,0x1,0x0,0x0,0xb81f8006,0x0,0xb81f8006,0x1b8000,0x0,0x1,0x1b8000,0x0,0xb81f8006,0xb81f8006,0xb81f8006,0x1b8000,0x1f8000,0x180000,0x6,0x6,0xb8078006,0x8,0x10,0x1,0x0,0x7e0,0x6,0x6,0x800,0x800,0xb81b9006,0xb81b8000,0x0,0x1,0x180000,0x0,0x1,0x180000,0x0,0x0,0x0,0x1,0x180000,0x0,0x1,0x180000,0x0,0x1,0x180000,0x0,0x0,0x1,0x0,0xb81b9006,0x0,0x0,0x4002000,0x4002000,0x38000000,0x0,0x80000000,0x38000,0x30000,0x40000,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0x0,0x7,0x20,0x0,0x0,0x0,0xa7,0x0,0xa7,0x0,0x0,0x0,0x0,0x0,0xa7,0xa7,0xa7,0x0,0x80,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x20,0x20,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x80,};
   }

  /** Constructor with InputStream. */
  public SPARQLParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SPARQLParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SPARQLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 106; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 106; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public SPARQLParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SPARQLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 106; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 106; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public SPARQLParser(SPARQLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 106; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(SPARQLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 106; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[110];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 106; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 110; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
